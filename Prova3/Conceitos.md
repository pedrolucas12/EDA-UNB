### Conceitos

1) Percursos em ordem, pôs ordem, e pre ordem nas Árvores binárias podem utilizar pilhas -> A afirmação está correta, pois os percursos são feitos em profundidade.

2) Percursos em largura nas árvores são feitos com o auxílio de pilhas -> A afirmação está incorreta, pois a ideia é proces sar os elementos dos ramos mais próximos a raiz primeiro.

3) A única maneira de implementar filas com listas encadeadas, mantendo a complexidade esperada das funções, é quando se utiliza lista duplamente encadeada -> Afirmação está incorreta, pois, como a comple xidade esperada é constante, uma lista simples mente encadeada com apontador para o último elemento resolveria o problema.

4) Todas árvores binárias de busca sempre possuem as chaves ordenadas no percurso in-order.

5) Nas árvores binárias de busca, toda chave é maior ou igual à chave de cada nó da sub-árvore es querda e menor ou igual a chave de cada nó da sub-arvore direita.

6) Arvores binárias são representadas com listas estáticas 

7) Arvores binárias são representadas com multilistas

8) Arvores binárias são representadas com listas encadendas

9) No shell sort, cada elemento reposicionado pode não estar na sua posição definitiva.

10) O principio do quick sort é ordenar, na posição definitiva, um único elemento por vez

11) O princípio do selection sort é encontrar o elemento correto para ocupar uma posição especi fica no vetor.

12) No quick sort, a cada elemento ordenado, gera-se subconjuntos sem garantia de ordenação.

13) O principio do merge sort è ordemar subconjun tos já ordenados, diminuindo o custo da operação por não ser necessário comparar todos as chaver entre si

14) O principio do insertion sort é ordenar cada ele mento no subconjunto dos seus antecessores.

15) No merge sort a ordenação é conquistada a cada intercalação de subconjuntos, no quick sort, a cada separação.

16) O princípio do bubble sort è reposicionar cada elemento maior que seu sucessor.

17) No insertion sort, cada elemento reposicionado pode não estar na sua posição definitiva.

18) O insertion sort, a cada reposicionamento de um elemento, sempre gera um subconjunto or denado.

19) No bubble sort, o maior elemento reposicionado já está na sua posição definitiva

20) O principio do shell sort é ordenar o elemento no subconjunto formado pelos seus antecessores que estão a uma distância específica entre si.

21) No merge sort, cada elemento reposicionado em um subconjunto ordenado, pode não estar na sua posição definitiva.

22) No selection sort, o menor elemento reposicio nado já está na sua posição definitiva.

23) No shell sort, ordena-se, inicialmente, os elemen- tos de forma mais intervalada, proporcionando uma possível aproximação mais rápida da sua po sição correta.

24) O merge sort é : Nao in-place, estavel, nao adaptativo 

25) A complexidade nasintética do merge sort para o pior caso: O(nlogn)

26) De acordo com a complexidade indicada na questão anterior, marque a função de recorrência do custo: F(n)=2F(n/2) + O(n): custo F(n/2) de cada merge e O(n) da recursão

27) A complexidade assintótica do quicksort para o pior caso: O(n^2)

28) De acordo com a complexidade indicada na questão anterior, marque a função de recorrência do custo: F(n)=F(n-1)+F(n-n)+O(n): custo F(n-1) e F(n-n) das recursões, e O(n) do merge

29) Arvore Completa : Uma arvore binaria completa é uma arvore binaria onde todos os niveis, exceto possivelmente o ultimo, estao completamente preenchidos, e todos os nos do ultimo nivel sao o mais a esquerda possivel.